# .github/workflows/main.yml - COMPLETE UPDATE with all fixes
name: Build WhisperDesk for All Platforms

on:
  push:
    branches: [ main, release ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  actions: read
  checks: write
  pull-requests: write

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: darwin
            arch: x64
            artifact: WhisperDesk-mac-x64
            electron_arch: x64
            electron_target: --mac --x64
          - os: macos-latest
            platform: darwin
            arch: arm64
            artifact: WhisperDesk-mac-arm64
            electron_arch: arm64
            electron_target: --mac --arm64
          - os: ubuntu-latest
            platform: linux
            arch: x64
            artifact: WhisperDesk-linux-x64
            electron_arch: x64
            electron_target: --linux --x64
          - os: windows-latest
            platform: win32
            arch: x64
            artifact: WhisperDesk-windows-x64
            electron_arch: x64
            electron_target: --win --x64

    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: latest

    # Platform-specific dependencies
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake libasound2-dev
        sudo apt-get install -y fuse libfuse2

    - name: Install macOS dependencies
      if: runner.os == 'macOS'
      run: |
        # Install Xcode command line tools if not present
        xcode-select --install || true
        # Install cmake via homebrew
        brew install cmake

    - name: Add MSBuild to PATH (Windows)
      if: runner.os == 'Windows'
      uses: microsoft/setup-msbuild@v2

    # Extract version from tag and update package.json
    - name: Set version from tag
      shell: bash
      run: |
        if [ "${{ github.ref_type }}" = "tag" ]; then
          # Extract version from tag (remove 'v' prefix)
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix if present
          
          echo "üè∑Ô∏è Setting version to: $VERSION"
          
          # Update main package.json
          if command -v jq &> /dev/null; then
            # Use jq if available
            jq --arg version "$VERSION" '.version = $version' package.json > package.json.tmp && mv package.json.tmp package.json
          else
            # Fallback to sed
            sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
          fi
          
          echo "‚úÖ Updated main package.json version to: $VERSION"
          grep '"version"' package.json
          
          # Also set as environment variable for electron-builder
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
        else
          echo "üîß Not a tag build, keeping existing version"
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "APP_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
        fi

    # Install main dependencies
    - name: Install main dependencies
      run: npm install

    # Install renderer dependencies
    - name: Install renderer dependencies
      shell: bash
      run: |
        cd src/renderer/whisperdesk-ui
        
        # Update renderer package.json version if this is a tag build
        if [ "${{ github.ref_type }}" = "tag" ]; then
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          
          echo "üè∑Ô∏è Updating renderer package.json version to: $VERSION"
          
          if command -v jq &> /dev/null; then
            jq --arg version "$VERSION" '.version = $version' package.json > package.json.tmp && mv package.json.tmp package.json
          else
            sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
          fi
          
          echo "‚úÖ Updated renderer package.json version"
          grep '"version"' package.json
        fi
        
        pnpm install --frozen-lockfile

    # Build whisper.cpp from source - UNIX platforms - UPDATED
    - name: Build whisper.cpp (Linux/macOS) - UPDATED for new naming
      if: runner.os != 'Windows'
      run: |
        echo "üî® Building whisper.cpp with cmake for Unix platforms..."
        
        # Clone whisper.cpp from OFFICIAL repository
        git clone https://github.com/ggml-org/whisper.cpp.git /tmp/whisper.cpp
        cd /tmp/whisper.cpp
        
        # Use modern cmake build approach
        cmake -B build -DCMAKE_BUILD_TYPE=Release
        cmake --build build --config Release --parallel $(nproc 2>/dev/null || sysctl -n hw.ncpu || echo 4)
        
        # Find the whisper binary with UPDATED naming priority
        WHISPER_BINARY=""
        
        # Priority order: newest names first, then legacy (UPDATED for April 2025 naming)
        BINARY_NAMES=("whisper-cpp" "whisper-whisper" "whisper-cli" "main" "whisper")
        BUILD_DIRS=("build/bin" "bin" "build")
        
        echo "üîç Searching for whisper binary..."
        for name in "${BINARY_NAMES[@]}"; do
          for dir in "${BUILD_DIRS[@]}"; do
            candidate="${dir}/${name}"
            if [ -f "$candidate" ]; then
              WHISPER_BINARY="$candidate"
              echo "‚úÖ Found whisper binary: $WHISPER_BINARY"
              break 2
            fi
          done
        done
        
        if [ -z "$WHISPER_BINARY" ]; then
          echo "‚ùå Could not find any whisper binary"
          echo "üìã Available files in build directories:"
          for dir in "${BUILD_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              echo "Directory: $dir"
              ls -la "$dir" 2>/dev/null || echo "  (empty or inaccessible)"
            fi
          done
          exit 1
        fi
        
        # Test the binary to ensure it's not a deprecated stub
        echo "üß™ Testing binary: $WHISPER_BINARY"
        if timeout 10s "$WHISPER_BINARY" --help > test_output.txt 2> test_error.txt; then
          # Check if it's a deprecated binary
          if grep -q "deprecated" test_error.txt 2>/dev/null; then
            echo "‚ö†Ô∏è Found deprecated binary, looking for recommended replacement..."
            
            # Extract recommended binary name from deprecation message
            RECOMMENDED=$(grep -o "Please use '[^']*'" test_error.txt | sed "s/Please use '//;s/'//")
            if [ -n "$RECOMMENDED" ]; then
              echo "üîç Looking for recommended binary: $RECOMMENDED"
              for dir in "${BUILD_DIRS[@]}"; do
                if [ -f "${dir}/${RECOMMENDED}" ]; then
                  WHISPER_BINARY="${dir}/${RECOMMENDED}"
                  echo "‚úÖ Found recommended binary: $WHISPER_BINARY"
                  break
                fi
              done
            fi
          fi
          
          echo "‚úÖ Binary test passed"
        else
          echo "‚ö†Ô∏è Binary test failed, but continuing..."
          cat test_error.txt 2>/dev/null || echo "No error output"
        fi
        
        # Copy to project binaries directory with standard name
        mkdir -p "$GITHUB_WORKSPACE/binaries"
        cp "$WHISPER_BINARY" "$GITHUB_WORKSPACE/binaries/whisper"
        chmod +x "$GITHUB_WORKSPACE/binaries/whisper"
        
        # Clean up test files
        rm -f test_output.txt test_error.txt
        
        echo "‚úÖ whisper.cpp built and installed successfully"
        echo "üìç Final binary: $GITHUB_WORKSPACE/binaries/whisper"

    # Build whisper.cpp from source - Windows - UPDATED
    - name: Build whisper.cpp (Windows) - UPDATED with OpenMP fix
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "üî® Building whisper.cpp for Windows with enhanced fixes..." -ForegroundColor Green
        
        # Clone whisper.cpp from OFFICIAL repository
        git clone https://github.com/ggml-org/whisper.cpp.git C:\temp\whisper.cpp
        Set-Location C:\temp\whisper.cpp
        
        Write-Host "‚úÖ Cloned whisper.cpp from official repository"
        
        # Configure with MSVC
        cmake -S . -B ./build -A x64 -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON
        
        Write-Host "‚úÖ Configured with MSVC"
        
        # Build using MSBuild
        Set-Location build
        msbuild ALL_BUILD.vcxproj -t:build -p:configuration=Release -p:platform=x64
        
        Write-Host "‚úÖ Built with MSBuild"
        
        # Find the whisper executable with UPDATED naming priority (April 2025)
        $buildDirs = @("bin\Release", "Release", "bin")
        $binaryNames = @("whisper-cpp.exe", "whisper-whisper.exe", "whisper-cli.exe", "main.exe", "whisper.exe")
        
        $foundBinary = $null
        $foundPath = ""
        
        Write-Host "üîç Searching for whisper binary with priority: $($binaryNames -join ', ')"
        
        foreach ($dir in $buildDirs) {
            if (-not (Test-Path $dir)) { continue }
            
            foreach ($name in $binaryNames) {
                $candidate = Join-Path $dir $name
                if (Test-Path $candidate) {
                    $foundBinary = $name
                    $foundPath = $candidate
                    Write-Host "‚úÖ Found binary: $foundPath" -ForegroundColor Green
                    break
                }
            }
            if ($foundBinary) { break }
        }
        
        if (-not $foundBinary) {
            Write-Host "‚ùå Could not find any whisper binary" -ForegroundColor Red
            Write-Host "üìã Available files in build directories:" -ForegroundColor Yellow
            foreach ($dir in $buildDirs) {
                if (Test-Path $dir) {
                    Write-Host "Directory: $dir" -ForegroundColor Cyan
                    Get-ChildItem $dir -Filter "*.exe" -ErrorAction SilentlyContinue | Select-Object Name, Length | Format-Table
                }
            }
            exit 1
        }
        
        # Test the binary to ensure it's not a deprecated stub
        Write-Host "üß™ Testing binary: $foundPath"
        
        $isDeprecated = $false
        $recommendedBinary = ""
        
        try {
            $process = Start-Process -FilePath $foundPath -ArgumentList "--help" -Wait -NoNewWindow -PassThru -RedirectStandardOutput "test_output.txt" -RedirectStandardError "test_error.txt"
            
            # Check for deprecation warning
            if (Test-Path "test_error.txt") {
                $errorContent = Get-Content "test_error.txt" -Raw
                if ($errorContent -match "deprecated") {
                    $isDeprecated = $true
                    Write-Host "‚ö†Ô∏è Found deprecated binary" -ForegroundColor Yellow
                    
                    # Extract recommended binary name
                    if ($errorContent -match "Please use '([^']+)'") {
                        $recommendedBinary = $matches[1]
                        Write-Host "üîç Looking for recommended binary: $recommendedBinary" -ForegroundColor Yellow
                        
                        # Search for the recommended binary
                        foreach ($dir in $buildDirs) {
                            $recommendedPath = Join-Path $dir $recommendedBinary
                            if (Test-Path $recommendedPath) {
                                $foundPath = $recommendedPath
                                $foundBinary = $recommendedBinary
                                Write-Host "‚úÖ Found recommended binary: $foundPath" -ForegroundColor Green
                                $isDeprecated = $false
                                break
                            }
                        }
                    }
                }
            }
            
            if (-not $isDeprecated) {
                Write-Host "‚úÖ Binary test passed" -ForegroundColor Green
            } else {
                Write-Host "‚ö†Ô∏è Still using deprecated binary, but continuing..." -ForegroundColor Yellow
            }
            
        } catch {
            Write-Host "‚ö†Ô∏è Binary test failed: $($_.Exception.Message)" -ForegroundColor Yellow
            Write-Host "üí° Continuing with build..." -ForegroundColor Yellow
        } finally {
            # Clean up test files
            Remove-Item "test_output.txt" -ErrorAction SilentlyContinue
            Remove-Item "test_error.txt" -ErrorAction SilentlyContinue
        }
        
        # Create target directory and copy binary
        $targetDir = "$env:GITHUB_WORKSPACE\binaries"
        New-Item -ItemType Directory -Force -Path $targetDir | Out-Null
        
        # Copy the found binary as whisper.exe (standard name for the app)
        Copy-Item $foundPath "$targetDir\whisper.exe" -Force
        Write-Host "‚úÖ Copied binary: $foundPath -> whisper.exe" -ForegroundColor Green
        
        # Copy all DLLs from the build directory
        $buildDir = Split-Path $foundPath -Parent
        $dlls = Get-ChildItem -Path $buildDir -Filter "*.dll" -ErrorAction SilentlyContinue
        
        if ($dlls.Count -gt 0) {
            foreach ($dll in $dlls) {
                Copy-Item $dll.FullName $targetDir -Force
                Write-Host "‚úÖ Copied DLL: $($dll.Name)" -ForegroundColor Green
            }
            Write-Host "üìã Total DLLs copied: $($dlls.Count)" -ForegroundColor Cyan
        } else {
            Write-Host "‚ö†Ô∏è No DLLs found in build directory: $buildDir" -ForegroundColor Yellow
        }
        
        Write-Host "‚úÖ whisper.cpp built and installed successfully" -ForegroundColor Green
        Write-Host "üìç Final binary: $targetDir\whisper.exe" -ForegroundColor Cyan

    # Package Visual C++ Runtime Dependencies (Windows) - UPDATED with OpenMP
    - name: Package VC++ Runtime (Windows) - UPDATED with OpenMP support
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "üì¶ Packaging Visual C++ Runtime Dependencies with OpenMP..." -ForegroundColor Green
        
        $targetDir = "$env:GITHUB_WORKSPACE\binaries"
        
        # Download VC++ Redistributable for users who need it
        $vcredistUrl = "https://aka.ms/vs/17/release/vc_redist.x64.exe"
        $vcredistPath = "$targetDir\vc_redist.x64.exe"
        
        try {
            Write-Host "‚¨áÔ∏è Downloading VC++ Redistributable..."
            Invoke-WebRequest -Uri $vcredistUrl -OutFile $vcredistPath -UseBasicParsing
            Write-Host "‚úÖ Downloaded VC++ Redistributable installer"
        } catch {
            Write-Host "‚ö†Ô∏è Failed to download VC++ Redistributable: $($_.Exception.Message)"
        }
        
        # Try to copy runtime DLLs from system (UPDATED with OpenMP)
        $runtimeDlls = @(
            @{ Name = "msvcp140.dll"; Path = "C:\Windows\System32\msvcp140.dll" },
            @{ Name = "vcruntime140.dll"; Path = "C:\Windows\System32\vcruntime140.dll" },
            @{ Name = "vcruntime140_1.dll"; Path = "C:\Windows\System32\vcruntime140_1.dll" },
            @{ Name = "vcomp140.dll"; Path = "C:\Windows\System32\vcomp140.dll" }  # OpenMP runtime
        )
        
        foreach ($dll in $runtimeDlls) {
            if (Test-Path $dll.Path) {
                try {
                    Copy-Item $dll.Path $targetDir -Force
                    Write-Host "‚úÖ Copied runtime DLL: $($dll.Name)"
                } catch {
                    Write-Host "‚ö†Ô∏è Could not copy $($dll.Name): $($_.Exception.Message)"
                }
            } else {
                Write-Host "‚ö†Ô∏è Runtime DLL not found: $($dll.Name)"
            }
        }

    # Enhanced binary verification - UPDATED
    - name: Enhanced binary verification
      shell: bash
      run: |
        echo "üîç Enhanced binary verification..."
        
        if [ "${{ runner.os }}" = "Windows" ]; then
          BINARY_PATH="binaries/whisper.exe"
        else
          BINARY_PATH="binaries/whisper"
        fi
        
        if [ -f "$BINARY_PATH" ]; then
          echo "‚úÖ Binary exists: $BINARY_PATH"
          ls -la "$BINARY_PATH"
          
          # Get file size to detect stubs
          if [ "${{ runner.os }}" = "Windows" ]; then
            SIZE=$(powershell -Command "(Get-Item '$BINARY_PATH').Length")
          else
            SIZE=$(stat -c%s "$BINARY_PATH" 2>/dev/null || stat -f%z "$BINARY_PATH")
          fi
          
          echo "üìä Binary size: $SIZE bytes"
          
          # Updated size check - modern whisper binaries are larger
          # Check if binary size is below the threshold for modern builds (200KB+ expected for non-stub binaries)
          if [ "$SIZE" -lt 200000 ]; then
            echo "‚ùå ERROR: Binary is small ($SIZE bytes) - likely a deprecated stub!"
            echo "üîç Modern whisper.cpp binaries should be 200KB+ with OpenMP/MSVC"
            
            # List all executables in binaries directory for debugging
            echo "üìã All executables in binaries directory:"
            if [ "${{ runner.os }}" = "Windows" ]; then
              powershell -Command "Get-ChildItem binaries -Filter '*.exe' | Format-Table Name, Length"
            else
              find binaries -type f -executable -exec ls -la {} \;
            fi
            
            echo "‚ùå BUILD FAILED: Binary too small - likely a stub"
            exit 1
          else
            echo "‚úÖ Binary size looks good ($SIZE bytes)"
          fi
          
        else
          echo "‚ùå Binary not found at: $BINARY_PATH"
          echo "üìã Contents of binaries directory:"
          ls -la binaries/ || echo "No binaries directory"
          exit 1
        fi

    # Download tiny model for inclusion
    - name: Download tiny model
      run: |
        mkdir -p models
        curl -L -o models/ggml-tiny.bin https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin

    # Build renderer
    - name: Build renderer
      run: |
        cd src/renderer/whisperdesk-ui
        pnpm run build

    # Configure electron-builder with FIXED binary packaging
    - name: Configure electron-builder (Unix) - FIXED
      if: runner.os != 'Windows'
      run: |
        echo "üîß Configuring electron-builder with BINARY PACKAGING and platform-specific naming..."
        
        # Create electron-builder config with proper binary packaging and unique naming and unique naming
        cat > electron-builder-fixed.json << 'EOF'
        {
          "appId": "com.yourcompany.whisperdesk",
          "productName": "WhisperDesk Enhanced",
          "directories": {
            "output": "dist"
          },
          "artifactName": "${productName}-${version}-${os}-${arch}.${ext}",
          "files": [
            "src/main/**/*",
            "src/renderer/whisperdesk-ui/dist/**/*",
            "src/shared/**/*",
            "node_modules/**/*",
            "package.json"
          ],
          "extraResources": [
            {
              "from": "binaries/",
              "to": "binaries/",
              "filter": ["**/*"]
            },
            {
              "from": "models/",
              "to": "models/",
              "filter": ["**/*"]
            }
          ],
          "win": {
            "target": [
              {
                "target": "nsis",
                "arch": ["x64"]
              },
              {
                "target": "zip",
                "arch": ["x64"]
              }
            ],
            "publisherName": "WhisperDesk Team",
            "verifyUpdateCodeSignature": false
          },
          "mac": {
            "target": [
              {
                "target": "dmg",
                "arch": ["x64", "arm64"]
              },
              {
                "target": "zip",
                "arch": ["x64", "arm64"]
              }
            ],
            "category": "public.app-category.productivity",
            "hardenedRuntime": true,
            "gatekeeperAssess": false
          },
          "linux": {
            "target": [
              {
                "target": "AppImage",
                "arch": ["x64"]
              },
              {
                "target": "deb",
                "arch": ["x64"]
              },
              {
                "target": "rpm",
                "arch": ["x64"]
              },
              {
                "target": "tar.gz",
                "arch": ["x64"]
              }
            ],
            "category": "AudioVideo"
          }
        }
        EOF
        
        echo "‚úÖ Electron-builder configuration created with PLATFORM-SPECIFIC NAMING"

    - name: Configure electron-builder (Windows) - FIXED
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "üîß Configuring electron-builder with BINARY PACKAGING and platform-specific naming..."
        
        # Create electron-builder config with proper binary packaging
        $config = @"
        {
          "appId": "com.yourcompany.whisperdesk",
          "productName": "WhisperDesk Enhanced",
          "directories": {
            "output": "dist"
          },
          "artifactName": "`${productName}-`${version}-`${os}-`${arch}.`${ext}",
          "files": [
            "src/main/**/*",
            "src/renderer/whisperdesk-ui/dist/**/*",
            "src/shared/**/*",
            "node_modules/**/*",
            "package.json"
          ],
          "extraResources": [
            {
              "from": "binaries/",
              "to": "binaries/",
              "filter": ["**/*"]
            },
            {
              "from": "models/",
              "to": "models/",
              "filter": ["**/*"]
            }
          ],
          "win": {
            "target": [
              {
                "target": "nsis",
                "arch": ["x64"]
              },
              {
                "target": "zip",
                "arch": ["x64"]
              }
            ],
            "publisherName": "WhisperDesk Team",
            "verifyUpdateCodeSignature": false
          },
          "mac": {
            "target": [
              {
                "target": "dmg",
                "arch": ["x64", "arm64"]
              },
              {
                "target": "zip",
                "arch": ["x64", "arm64"]
              }
            ],
            "category": "public.app-category.productivity",
            "hardenedRuntime": true,
            "gatekeeperAssess": false
          },
          "linux": {
            "target": [
              {
                "target": "AppImage",
                "arch": ["x64"]
              },
              {
                "target": "deb",
                "arch": ["x64"]
              },
              {
                "target": "rpm",
                "arch": ["x64"]
              },
              {
                "target": "tar.gz",
                "arch": ["x64"]
              }
            ],
            "category": "AudioVideo"
          }
        }
        "@
        
        # Write to file
        $config | Out-File -FilePath "electron-builder-fixed.json" -Encoding UTF8
        
        Write-Host "‚úÖ Electron-builder configuration created with PLATFORM-SPECIFIC NAMING"

    # Verify version before building
    - name: Verify version configuration
      shell: bash
      run: |
        echo "üîç Verifying version configuration..."
        echo "üìã Git ref: ${{ github.ref }}"
        echo "üìã Git ref type: ${{ github.ref_type }}"
        echo "üìã Git ref name: ${{ github.ref_name }}"
        echo "üìã App version (env): $APP_VERSION"
        echo "üìã Package.json version: $(node -p "require('./package.json').version")"
        
        # Verify versions match
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        if [ "$APP_VERSION" != "$PACKAGE_VERSION" ]; then
          echo "‚ö†Ô∏è Warning: Environment version ($APP_VERSION) differs from package.json ($PACKAGE_VERSION)"
        else
          echo "‚úÖ Version consistency verified: $APP_VERSION"
        fi

    # Build Electron app for specific platform
    - name: Build Electron app (macOS)
      if: matrix.platform == 'darwin'
      env:
        CSC_IDENTITY_AUTO_DISCOVERY: false
      run: |
        npm run build:skip-whisper
        npx electron-builder ${{ matrix.electron_target }} --publish=never --config electron-builder-fixed.json

    - name: Build Electron app (Linux)
      if: matrix.platform == 'linux'
      run: |
        npm run build:skip-whisper
        npx electron-builder ${{ matrix.electron_target }} --publish=never --config electron-builder-fixed.json

    - name: Build Electron app (Windows)
      if: matrix.platform == 'win32'
      env:
        CSC_IDENTITY_AUTO_DISCOVERY: false
      run: |
        npm run build:skip-whisper
        npx electron-builder ${{ matrix.electron_target }} --publish=never --config electron-builder-fixed.json

    # VERIFY: Check for unwanted ia32 builds
    - name: Verify no ia32 builds created
      shell: bash
      run: |
        echo "üîç Checking for unwanted ia32/32-bit builds..."
        
        # Check for ia32 in filenames
        if find dist/ -name "*ia32*" 2>/dev/null | grep -q .; then
          echo "‚ùå ERROR: Found ia32 builds when only x64 was expected!"
          find dist/ -name "*ia32*"
          exit 1
        else
          echo "‚úÖ No ia32 builds found - good!"
        fi
        
        # List all built files for verification
        echo "üìã Built files:"
        find dist/ -type f -name "*.exe" -o -name "*.dmg" -o -name "*.zip" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" -o -name "*.tar.gz" | sort

    # Upload artifacts with clear platform separation
    - name: Upload macOS artifacts
      if: matrix.platform == 'darwin'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          dist/*.dmg
          dist/*.zip
        retention-days: 30

    - name: Upload Linux artifacts
      if: matrix.platform == 'linux'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          dist/*.AppImage
          dist/*.deb
          dist/*.rpm
          dist/*.tar.gz
        retention-days: 30

    - name: Upload Windows artifacts
      if: matrix.platform == 'win32'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          dist/*.exe
          dist/*.zip
        retention-days: 30

  # Create release with proper file organization
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: build
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      actions: read
      id-token: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Set clean version for release notes
      id: version
      run: |
        # Extract clean version (without 'v' prefix) for release notes
        CLEAN_VERSION="${{ github.ref_name }}"
        CLEAN_VERSION="${CLEAN_VERSION#v}"
        echo "clean=$CLEAN_VERSION" >> $GITHUB_OUTPUT
        echo "üè∑Ô∏è Clean version for release notes: $CLEAN_VERSION"

    - name: Organize release files
      run: |
        echo "üîß Organizing release files by platform with deduplication..."
        mkdir -p release-files
        
        # Function to copy file with unique naming if duplicate exists
        copy_unique() {
          local src="$1"
          local dst="$2"
          local filename=$(basename "$src")
          local counter=1
          local target="$dst/$filename"
          
          # If file already exists, add counter
          while [ -f "$target" ]; do
            local base="${filename%.*}"
            local ext="${filename##*.}"
            if [ "$base" = "$filename" ]; then
              # No extension
              target="$dst/${base}-${counter}"
            else
              # Has extension
              target="$dst/${base}-${counter}.${ext}"
            fi
            counter=$((counter + 1))
          done
          
          cp "$src" "$target"
          echo "üìÅ Copied: $src -> $target"
        }
        
        # Process each artifact directory
        for artifact_dir in artifacts/*/; do
          echo "üîç Processing: $artifact_dir"
          
          # Determine platform from directory name
          if [[ "$artifact_dir" == *"windows"* ]]; then
            platform="windows"
          elif [[ "$artifact_dir" == *"mac"* ]]; then
            platform="macos"
          elif [[ "$artifact_dir" == *"linux"* ]]; then
            platform="linux"
          else
            echo "‚ö†Ô∏è Unknown platform for $artifact_dir, skipping..."
            continue
          fi
          
          # Create platform directory
          mkdir -p "release-files/$platform"
          
          # Copy files with deduplication
          find "$artifact_dir" -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.zip" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" -o -name "*.tar.gz" \) | while read -r file; do
            copy_unique "$file" "release-files/$platform"
          done
        done
        
        echo "üìã Final release file structure:"
        find release-files/ -type f | sort

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: release-files/**/*
        draft: false
        prerelease: false
        generate_release_notes: true
        name: "WhisperDesk Enhanced ${{ github.ref_name }}"
        body: |
          ## WhisperDesk Enhanced ${{ github.ref_name }}
          
          üéâ **New Release Available!**
          
          ### üì¶ Download Options:
          
          **üñ•Ô∏è Windows (64-bit only)**:
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-win-x64.exe` - Installer
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-win-x64.zip` - Portable version
          
          **üçé macOS**:
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-x64.dmg` - Intel Macs
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-x64.zip` - Intel Macs (Portable)
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-arm64.dmg` - Apple Silicon Macs
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-arm64.zip` - Apple Silicon Macs (Portable)
          
          **üêß Linux**:
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.AppImage` - Portable (recommended)
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.deb` - Debian/Ubuntu package
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.rpm` - Red Hat/Fedora package
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.tar.gz` - Generic Linux archive
          
          ### ‚ú® Features:
          - üéµ Native whisper.cpp integration for fast, offline transcription
          - üì± Cross-platform support (Windows, macOS, Linux)
          - üîÑ Real-time progress tracking
          - üíæ Persistent state management
          - üéØ Multiple model support (Tiny, Base, Small, Medium, Large)
          - üìÅ Drag & drop file upload
          - üé® Modern, responsive UI
          
          ### üöÄ Quick Start:
          1. **Download**: Choose the appropriate file for your platform above
          2. **Install**: 
             - Windows: Run the installer or extract the zip
             - macOS: Open the .dmg and drag to Applications, or extract the zip
             - Linux: Make AppImage executable, install package, or extract archive
          3. **Setup**: Launch WhisperDesk and go to Models tab
          4. **Download Model**: Download a transcription model (start with Tiny)
          5. **Transcribe**: Upload audio/video files and start transcribing!
          
          ### üîß Troubleshooting:
          - **Windows**: If you get a "missing DLL" error, run the included `vc_redist.x64.exe` redistributable
          - **macOS**: Right-click ‚Üí Open if blocked by Gatekeeper
          - **Linux**: `chmod +x *.AppImage` to make executable
          
          ---
          Auto-generated release notes below ‚¨áÔ∏è
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}