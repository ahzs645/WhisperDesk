# .github/workflows/main.yml - FIXED: Added diarization build + electron-builder fixes
name: Build WhisperDesk for All Platforms

on:
  push:
    branches: [ main, master, release ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create new release'
        required: true
        type: boolean
      release_tag:
        description: 'Release tag name (e.g., v2.1.0)'
        required: false
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref && github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: read
  checks: write
  pull-requests: write

env:
  BRANCH_NAME: ${{ github.head_ref || github.ref_name }}

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      file_version: ${{ steps.version.outputs.file_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Determine version
        id: version
        shell: bash
        run: |
          if [ "${{ github.ref_type }}" = "tag" ]; then
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"
            TAG_NAME="${{ github.ref_name }}"
            FILE_VERSION="$VERSION"
            echo "🏷️ Official release: $TAG_NAME"
            
            cat package.json | jq --arg version "$VERSION" '.version = $version' > package.json.tmp && mv package.json.tmp package.json
            echo "📦 Updated package.json to version: $VERSION"
            
          elif [ -n "${{ github.event.inputs.release_tag }}" ]; then
            TAG_NAME="${{ github.event.inputs.release_tag }}"
            VERSION="${TAG_NAME#v}"
            FILE_VERSION="$VERSION"
            echo "🏷️ Manual release: $TAG_NAME"
            
            cat package.json | jq --arg version "$VERSION" '.version = $version' > package.json.tmp && mv package.json.tmp package.json
            echo "📦 Updated package.json to version: $VERSION"
            
          else
            PACKAGE_VERSION=$(node -p "require('./package.json').version")
            VERSION="${PACKAGE_VERSION}-dev"
            TAG_NAME="dev"
            FILE_VERSION="dev"
            echo "🚧 Development build: $VERSION"
            echo "📁 File version: $FILE_VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "file_version=$FILE_VERSION" >> $GITHUB_OUTPUT
          echo "🏷️ Version: $VERSION"
          echo "🏷️ Tag: $TAG_NAME"
          echo "📁 File Version: $FILE_VERSION"

  # Add this job after determine-version and before the build jobs
  update-package-version:
    if: github.ref_type == 'tag' || github.event.inputs.create_release == 'true'
    runs-on: ubuntu-latest
    needs: determine-version
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Update package.json versions
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          echo "🏷️ Updating package.json to version: $VERSION"
          
          # Update main package.json
          if [ -f "package.json" ]; then
            cat package.json | jq --arg version "$VERSION" '.version = $version' > package.json.tmp
            mv package.json.tmp package.json
            echo "✅ Updated main package.json to $VERSION"
          fi
          
          # Update renderer package.json if it exists
          if [ -f "src/renderer/whisperdesk-ui/package.json" ]; then
            cd src/renderer/whisperdesk-ui
            cat package.json | jq --arg version "$VERSION" '.version = $version' > package.json.tmp
            mv package.json.tmp package.json
            echo "✅ Updated renderer package.json to $VERSION"
            cd "$GITHUB_WORKSPACE"
          fi

      - name: Commit version updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add package.json
            if [ -f "src/renderer/whisperdesk-ui/package.json" ]; then
              git add src/renderer/whisperdesk-ui/package.json
            fi
            
            git commit -m "🔖 Update version to ${{ needs.determine-version.outputs.version }}"
            git push origin HEAD:${{ github.ref_name }}
            echo "✅ Version updates committed and pushed"
          fi

  # Windows build
  build-windows:
    runs-on: windows-latest
    needs: [determine-version]

    strategy:
      matrix:
        arch: [x64]
        build_type: [Release]
        sdl2: [ON]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Add MSBuild to PATH
        uses: microsoft/setup-msbuild@v2
      - name: Install jsoncpp (vcpkg)
        shell: pwsh
        run: |
          $vcpkgRoot = "C:/vcpkg"
          & "$vcpkgRoot/vcpkg.exe" install jsoncpp:x64-windows
          echo "VCPKG_ROOT=$vcpkgRoot" >> $env:GITHUB_ENV
          echo "VCPKG_DEFAULT_TRIPLET=x64-windows" >> $env:GITHUB_ENV
          echo "CMAKE_TOOLCHAIN_FILE=$vcpkgRoot/scripts/buildsystems/vcpkg.cmake" >> $env:GITHUB_ENV

      - name: Update main package.json version
        shell: pwsh
        run: |
          $version = "${{ needs.determine-version.outputs.version }}"
          Write-Host "🏷️ Setting main package.json version to: $version"
          
          if (Test-Path "package.json") {
            $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
            $packageJson.version = $version
            
            # FIXED: Ensure main entry point is correct
            $packageJson.main = "src/main/main.js"
            
            # FIXED: Update build configuration for better electron-builder compatibility
            if (-not $packageJson.build) { $packageJson.build = @{} }
            $packageJson.build.appId = "com.whisperdesk.enhanced"
            $packageJson.build.productName = "WhisperDesk"
            $packageJson.build.directories = @{ output = "dist" }
            $packageJson.build.files = @(
              "src/**/*",
              "binaries/**/*",
              "models/**/*",
              "!binaries/models/**/*",
              "package.json"
            )
            $packageJson.build.extraResources = @(
              @{ from = "binaries/"; to = "binaries/"; filter = @("**/*") }
            )
            
            $packageJson.build.win = @{
              target = @(
                @{ target = "nsis"; arch = @("x64") },
                @{ target = "zip"; arch = @("x64") }
              )
              icon = "resources/icons/icon.ico"
            }
            
            $packageJson | ConvertTo-Json -Depth 100 | Set-Content package.json -Encoding UTF8
            Write-Host "✅ Updated main package.json"
          }

      # Install dependencies
      - name: Install main dependencies
        env:
          CI: true
          GITHUB_ACTIONS: true
          npm_config_ignore_scripts: true
        run: npm install

      - name: Install renderer dependencies
        shell: pwsh
        run: |
          if (Test-Path "src/renderer/whisperdesk-ui") {
            Set-Location "src/renderer/whisperdesk-ui"
            
            if (Test-Path "package.json") {
              $version = "${{ needs.determine-version.outputs.version }}"
              $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
              $packageJson.version = $version
              $packageJson | ConvertTo-Json -Depth 100 | Set-Content package.json
              Write-Host "✅ Updated renderer package.json version"
            }
            
            pnpm install --frozen-lockfile
            Set-Location "$env:GITHUB_WORKSPACE"
          }

      # Build whisper.cpp
      - name: Fetch SDL2 and set SDL2_DIR
        run: |
          C:/msys64/usr/bin/wget.exe -qO sdl2.zip https://github.com/libsdl-org/SDL/releases/download/release-2.28.5/SDL2-devel-2.28.5-VC.zip
          7z x sdl2.zip
          echo "SDL2_DIR=$env:GITHUB_WORKSPACE/SDL2-2.28.5/cmake" >> $env:GITHUB_ENV

      - name: Clone and build whisper.cpp
        shell: pwsh
        run: |
          Write-Host "🔧 Building whisper.cpp..."
          
          $tempDir = Join-Path $env:TEMP "whisper-cpp-official"
          if (Test-Path $tempDir) { Remove-Item -Recurse -Force $tempDir }
          
          git clone --depth 1 https://github.com/ggerganov/whisper.cpp.git $tempDir
          Set-Location $tempDir
          
          cmake -S . -B ./build -A ${{ matrix.arch }} `
            -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} `
            -DBUILD_SHARED_LIBS=ON `
            -DWHISPER_SDL2=${{ matrix.sdl2 }} `
            -DWHISPER_BUILD_EXAMPLES=ON
          
          Set-Location ./build
          msbuild ALL_BUILD.vcxproj -t:build -p:configuration=${{ matrix.build_type }} -p:platform=${{ matrix.arch }}
          
          $binariesDir = Join-Path $env:GITHUB_WORKSPACE "binaries"
          New-Item -ItemType Directory -Force -Path $binariesDir
          
          $buildBin = "bin/${{ matrix.build_type }}"
          
          Copy-Item "$buildBin/whisper.dll" $binariesDir -Force
          Copy-Item "$buildBin/ggml.dll" $binariesDir -Force
          Copy-Item "$buildBin/ggml-base.dll" $binariesDir -Force  
          Copy-Item "$buildBin/ggml-cpu.dll" $binariesDir -Force
          Copy-Item "$buildBin/whisper-cli.exe" $binariesDir -Force
          Copy-Item "$env:SDL2_DIR/../lib/${{ matrix.arch }}/SDL2.dll" $binariesDir -Force
          
          Write-Host "✅ Whisper binaries copied"
          Set-Location $env:GITHUB_WORKSPACE

      # 🔴 NEW: Build enhanced diarization system
      - name: Build enhanced diarization system
        shell: pwsh
        run: |
          Write-Host "🎭 Building enhanced multi-speaker diarization system..."
          try {
            npm run build:diarization
            Write-Host "✅ Diarization build completed successfully"
          } catch {
            Write-Host "⚠️ Diarization build failed: $($_.Exception.Message)"
            Write-Host "💡 Multi-speaker detection will be disabled"
            # Don't fail the entire build
          }

      # Verify diarization build
      - name: Verify diarization build
        shell: pwsh
        run: |
          $diarizeExe = "binaries/diarize-cli.exe"
          if (Test-Path $diarizeExe) {
            $size = (Get-Item $diarizeExe).Length / 1KB
            Write-Host "✅ Diarization binary found: $diarizeExe ($([math]::Round($size)) KB)"
            
            # Check for required models
            $segmentModel = "models/segmentation-3.0.onnx"
            $embeddingModel = "models/embedding-1.0.onnx"
            
            if (Test-Path $segmentModel) {
              $size = (Get-Item $segmentModel).Length / 1MB
              Write-Host "✅ Segmentation model: $([math]::Round($size)) MB"
            } else {
              Write-Host "⚠️ Segmentation model missing: $segmentModel"
            }
            
            if (Test-Path $embeddingModel) {
              $size = (Get-Item $embeddingModel).Length / 1MB
              Write-Host "✅ Embedding model: $([math]::Round($size)) MB"
            } else {
              Write-Host "⚠️ Embedding model missing: $embeddingModel"
            }
          } else {
            Write-Host "⚠️ Diarization binary not found - single speaker mode only"
          }

      # Download tiny model
      - name: Download tiny model
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "models" | Out-Null
          try {
            Invoke-WebRequest -Uri "https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin" -OutFile "models/ggml-tiny.bin" -TimeoutSec 300
            Write-Host "✅ Model downloaded successfully"
            $modelSize = (Get-Item "models/ggml-tiny.bin").Length / 1MB
            Write-Host "📊 Model size: $([math]::Round($modelSize, 1)) MB"
          } catch {
            Write-Host "❌ Failed to download model: $($_.Exception.Message)"
            exit 1
          }

      # Build renderer
      - name: Build renderer
        shell: pwsh
        run: |
          if (Test-Path "src/renderer/whisperdesk-ui") {
            Set-Location "src/renderer/whisperdesk-ui"
            try {
              pnpm run build
              Write-Host "✅ Renderer build completed"
            } catch {
              Write-Host "❌ Renderer build failed: $($_.Exception.Message)"
              exit 1
            }
            Set-Location "$env:GITHUB_WORKSPACE"
          } else {
            Write-Host "⚠️ Renderer directory not found, skipping"
          }

      # 🔴 FIXED: Better file structure verification
      - name: Verify complete build structure
        shell: pwsh
        run: |
          Write-Host "📋 Verifying complete build structure..."
          
          # Check main entry point
          if (Test-Path "src/main/main.js") {
            Write-Host "✅ Main entry point: src/main/main.js"
          } else {
            Write-Host "❌ CRITICAL: Main entry point missing: src/main/main.js"
            exit 1
          }
          
          # Check package.json
          if (Test-Path "package.json") {
            $pkg = Get-Content package.json -Raw | ConvertFrom-Json
            Write-Host "✅ Package.json main field: $($pkg.main)"
            Write-Host "✅ Package.json version: $($pkg.version)"
          }
          
          # Check binaries
          $requiredBinaries = @("whisper.dll", "ggml.dll", "ggml-base.dll", "ggml-cpu.dll", "SDL2.dll", "whisper-cli.exe")
          foreach ($binary in $requiredBinaries) {
            if (Test-Path "binaries/$binary") {
              Write-Host "✅ $binary found"
            } else {
              Write-Host "❌ $binary missing"
              exit 1
            }
          }
          
          # Check renderer build
          if (Test-Path "src/renderer/whisperdesk-ui/dist") {
            Write-Host "✅ Renderer build found"
          } else {
            Write-Host "❌ Renderer build missing"
            exit 1
          }
          
          Write-Host "✅ All build prerequisites verified"

      # 🔐 NEW: Setup Windows Code Signing
      - name: Setup Windows Code Signing
        shell: pwsh
        run: |
          Write-Host "🔐 Setting up Windows code signing..."
          
          # Create a self-signed certificate for GitHub Actions
          try {
            $cert = New-SelfSignedCertificate `
              -DnsName "WhisperDesk" `
              -Type CodeSigning `
              -CertStoreLocation "cert:\LocalMachine\My" `
              -FriendlyName "WhisperDesk Self-Signed Certificate" `
              -NotAfter (Get-Date).AddDays(30)
            
            $password = ConvertTo-SecureString -String "temppass123" -Force -AsPlainText
            $certPath = Join-Path $env:GITHUB_WORKSPACE "temp-cert.pfx"
            
            Export-PfxCertificate -Cert $cert -FilePath $certPath -Password $password | Out-Null
            
            # Set environment variables for electron-builder
            echo "WIN_CSC_LINK=$certPath" >> $env:GITHUB_ENV
            echo "WIN_CSC_KEY_PASSWORD=temppass123" >> $env:GITHUB_ENV
            echo "CSC_LINK=$certPath" >> $env:GITHUB_ENV
            echo "CSC_KEY_PASSWORD=temppass123" >> $env:GITHUB_ENV
            
            Write-Host "✅ Self-signed certificate created: $certPath"
            
            # Install signtool if not available
            $signtoolPath = Get-Command signtool.exe -ErrorAction SilentlyContinue
            if (-not $signtoolPath) {
              Write-Host "📦 Installing Windows SDK for signtool..."
              choco install windows-sdk-10-version-2004-all -y --no-progress --limitoutput
              $env:SIGNTOOL_PATH = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x64\signtool.exe"
              echo "SIGNTOOL_PATH=$env:SIGNTOOL_PATH" >> $env:GITHUB_ENV
            } else {
              echo "SIGNTOOL_PATH=$($signtoolPath.Source)" >> $env:GITHUB_ENV
            }
            
          } catch {
            Write-Host "⚠️ Certificate creation failed: $($_.Exception.Message)"
            Write-Host "ℹ️ Build will continue without code signing"
            echo "WIN_CSC_LINK=" >> $env:GITHUB_ENV
            echo "CSC_LINK=" >> $env:GITHUB_ENV
          }

      # 🔐 NEW: Create Windows signing script
      - name: Create Windows signing script
        shell: pwsh
        run: |
          $scriptContent = @'
          #!/usr/bin/env node
          const { execSync } = require('child_process');
          const path = require('path');
          const fs = require('fs');
          
          async function signWindows(configuration) {
            const { path: filePath, isWin } = configuration;
            
            if (!isWin) return;
            
            console.log('🔐 Signing Windows executable:', path.basename(filePath));
            
            try {
              const certFile = process.env.CSC_LINK;
              const certPassword = process.env.CSC_KEY_PASSWORD;
              const signtoolPath = process.env.SIGNTOOL_PATH || 'signtool';
              
              if (certFile && fs.existsSync(certFile)) {
                const command = `"${signtoolPath}" sign /f "${certFile}" /p "${certPassword}" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 "${filePath}"`;
                execSync(command, { stdio: 'inherit' });
                console.log('✅ Windows executable signed');
              } else {
                console.log('⚠️ No certificate available');
              }
            } catch (error) {
              console.warn('⚠️ Signing failed (non-critical):', error.message);
            }
          }
          
          module.exports = signWindows;
          '@
          
          New-Item -ItemType Directory -Force -Path "scripts" | Out-Null
          $scriptContent | Set-Content -Path "scripts/sign-windows.js" -Encoding UTF8
          Write-Host "✅ Windows signing script created"

      # 🔴 MODIFIED: Build Electron app (Windows) - Add signing environment
      - name: Build Electron app
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: false
          DEBUG: electron-builder
          # 🔐 Code signing environment
          WIN_CSC_LINK: ${{ env.WIN_CSC_LINK }}
          WIN_CSC_KEY_PASSWORD: ${{ env.WIN_CSC_KEY_PASSWORD }}
          CSC_LINK: ${{ env.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ env.CSC_KEY_PASSWORD }}
          SIGNTOOL_PATH: ${{ env.SIGNTOOL_PATH }}
          # NEW: Add file version for simplified dev naming
          VERSION: ${{ needs.determine-version.outputs.version }}
          FILE_VERSION: ${{ needs.determine-version.outputs.file_version }}
        shell: pwsh
        run: |
          Write-Host "🔧 Starting Electron build with code signing..."
          
          try {
            # Build with signing
            npx electron-builder --win --x64 --publish=never
            
            Write-Host "✅ Electron build completed"
            
            # Rename ZIP files to Portable versions with simplified dev naming
            Write-Host "🔧 Renaming ZIP files to Portable versions..."
            node scripts/rename-portable.js
            
            # Verify outputs
            Write-Host "📋 Build outputs:"
            if (Test-Path "dist") {
              Get-ChildItem -Path "dist" -Filter "*.exe" | ForEach-Object {
                $size = [math]::Round($_.Length / 1MB, 1)
                Write-Host "  $($_.Name) - $size MB"
              }
              Get-ChildItem -Path "dist" -Filter "*.zip" | ForEach-Object {
                $size = [math]::Round($_.Length / 1MB, 1)
                Write-Host "  $($_.Name) - $size MB"
              }
            }
          } catch {
            Write-Host "❌ Electron build failed: $($_.Exception.Message)"
            exit 1
          }

      # 🔐 NEW: Verify Code Signing
      - name: Verify Code Signing
        shell: bash
        run: |
          echo "🔍 Verifying code signing status..."
          
          if [ "${{ runner.os }}" = "Windows" ]; then
            # Check Windows executable signatures
            for exe in dist/*.exe; do
              if [ -f "$exe" ]; then
                echo "Checking: $(basename "$exe")"
                # Use Get-AuthenticodeSignature if available
                powershell -Command "
                  try {
                    \$sig = Get-AuthenticodeSignature '$exe'
                    if (\$sig.Status -eq 'Valid') {
                      Write-Host '✅ Signed: $(basename "$exe")'
                    } else {
                      Write-Host '⚠️ Status: ' \$sig.Status ' - $(basename "$exe")'
                    }
                  } catch {
                    Write-Host 'ℹ️ Could not verify signature for $(basename "$exe")'
                  }
                " || echo "ℹ️ Signature verification not available"
              fi
            done
          fi

      # Upload artifacts
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: WhisperDesk-windows-${{ matrix.arch }}
          path: |
            dist/*.exe
            dist/*.zip
          retention-days: 30
          if-no-files-found: error

  # macOS build (with diarization)
  build-macos:
    runs-on: macos-latest
    needs: [determine-version]

    strategy:
      matrix:
        arch: [x64, arm64]
        build_type: [Release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install dependencies
        run: |
          brew update
          brew install cmake

      - name: Fix package.json dependencies and update version
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          echo "🏷️ Setting version to: $VERSION"
          
          if [ -f "package.json" ]; then
            cat package.json | jq --arg version "$VERSION" '
              .version = $version |
              .main = "src/main/main.js" |
              if .dependencies.electron then
                .devDependencies.electron = .dependencies.electron |
                del(.dependencies.electron)
              else
                .
              end |
              .build.appId = "com.whisperdesk.enhanced" |
              .build.productName = "WhisperDesk" |
              .build.directories.output = "dist" |
              .build.files = [
                "src/**/*",
                "binaries/**/*", 
                "models/**/*",
                "!binaries/models/**/*",
                "package.json"
              ] |
              .build.extraResources = [
                {"from": "binaries/", "to": "binaries/", "filter": ["**/*"]}
              ] |
              .build.mac = {
                "target": [
                  {"target": "zip", "arch": ["'${{ matrix.arch }}'"]}
                ],
                "icon": "resources/icons/icon.icns"
              }
            ' > package.json.tmp && mv package.json.tmp package.json
            
            echo "✅ Updated package.json"
            echo "📋 Package.json main field: $(cat package.json | jq -r '.main')"
          fi

      - name: Install main dependencies
        run: npm install

      - name: Install renderer dependencies
        run: |
          if [ -d "src/renderer/whisperdesk-ui" ]; then
            cd src/renderer/whisperdesk-ui
            
            if [ -f "package.json" ]; then
              VERSION="${{ needs.determine-version.outputs.version }}"
              cat package.json | jq --arg version "$VERSION" '.version = $version' > package.json.tmp
              mv package.json.tmp package.json
              echo "✅ Updated renderer package.json version"
            fi
            
            pnpm install --frozen-lockfile
          fi

      # Build whisper.cpp
      - name: Build whisper.cpp with verification
        run: |
          echo "🔨 Starting whisper.cpp build for macOS..."
          echo "Platform: $(uname -s)"
          echo "Architecture: $(uname -m)"
          
          npm run build:whisper
          
          mkdir -p binaries
          PROJECT_BINARY_PATH="binaries/whisper-cli"

          if [ -f "$PROJECT_BINARY_PATH" ]; then
            echo "✅ Binary found: $PROJECT_BINARY_PATH"
            chmod +x "$PROJECT_BINARY_PATH"
            ls -la "$PROJECT_BINARY_PATH"
            echo "📊 Binary size: $(ls -lh $PROJECT_BINARY_PATH | awk '{print $5}')"
          else
            echo "❌ Binary not found at expected location: $PROJECT_BINARY_PATH"
            exit 1
          fi
        shell: bash

      # 🔴 NEW: Build enhanced diarization system for macOS
      - name: Build enhanced diarization system
        run: |
          echo "🎭 Building enhanced multi-speaker diarization system for macOS..."
          if npm run build:diarization; then
            echo "✅ Diarization build completed successfully"
          else
            echo "⚠️ Diarization build failed - multi-speaker detection will be disabled"
            # Don't fail the entire build
          fi
        shell: bash

      # Verify diarization build
      - name: Verify diarization build
        run: |
          DIARIZE_BIN="binaries/diarize-cli"
          if [ -f "$DIARIZE_BIN" ]; then
            echo "✅ Diarization binary found: $DIARIZE_BIN"
            chmod +x "$DIARIZE_BIN"
            ls -la "$DIARIZE_BIN"
            echo "📊 Binary size: $(ls -lh $DIARIZE_BIN | awk '{print $5}')"
            
            # Check for required models
            if [ -f "models/segmentation-3.0.onnx" ]; then
              echo "✅ Segmentation model found ($(ls -lh models/segmentation-3.0.onnx | awk '{print $5}'))"
            else
              echo "⚠️ Segmentation model missing"
            fi
            
            if [ -f "models/embedding-1.0.onnx" ]; then
              echo "✅ Embedding model found ($(ls -lh models/embedding-1.0.onnx | awk '{print $5}'))"
            else
              echo "⚠️ Embedding model missing"
            fi
            
            # Check library dependencies on macOS
            echo "🔗 Library dependencies:"
            otool -L "$DIARIZE_BIN" || echo "Could not check dependencies"
            
          else
            echo "⚠️ Diarization binary not found - single speaker mode only"
          fi
        shell: bash

      # Download tiny model
      - name: Download tiny model
        run: |
          mkdir -p models
          curl -L -o models/ggml-tiny.bin https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin

      # Build renderer
      - name: Build renderer
        run: |
          if [ -d "src/renderer/whisperdesk-ui" ]; then
            cd src/renderer/whisperdesk-ui
            pnpm run build
          fi

      # 🔴 FIXED: Better verification for macOS
      - name: Verify build prerequisites
        run: |
          echo "📋 Verifying all build prerequisites..."
          
          # Check main entry point
          if [ -f "src/main/main.js" ]; then
            echo "✅ Main entry point: src/main/main.js"
          else
            echo "❌ CRITICAL: Main entry point missing"
            exit 1
          fi
          
          # Check binary exists and is executable
          BINARY_PATH="binaries/whisper-cli"
          if [ -f "$BINARY_PATH" ] && [ -x "$BINARY_PATH" ]; then
            echo "✅ whisper-cli binary found and executable"
            echo "📊 Size: $(ls -lh $BINARY_PATH | awk '{print $5}')"
          else
            echo "❌ whisper-cli binary missing or not executable"
            exit 1
          fi
          
          # Check model exists
          if [ -f "models/ggml-tiny.bin" ]; then
            echo "✅ Model ready"
          else
            echo "❌ Model missing"
            exit 1
          fi
          
          # Check renderer build
          if [ -d "src/renderer/whisperdesk-ui/dist" ]; then
            echo "✅ Renderer build found"
          else
            echo "❌ Renderer build missing"
            exit 1
          fi

      # 🔐 NEW: Setup macOS Code Signing
      - name: Setup macOS Code Signing
        run: |
          echo "🔐 Setting up macOS ad-hoc code signing..."
          
          # Disable automatic code signing by electron-builder
          export CSC_IDENTITY_AUTO_DISCOVERY=false
          echo "CSC_IDENTITY_AUTO_DISCOVERY=false" >> $GITHUB_ENV
          
          # Set ad-hoc signing mode
          echo "APPLE_ID=" >> $GITHUB_ENV
          echo "APPLE_APP_SPECIFIC_PASSWORD=" >> $GITHUB_ENV
          echo "APPLE_TEAM_ID=" >> $GITHUB_ENV
          
          echo "✅ macOS signing environment configured for ad-hoc signing"

      # 🔐 NEW: Create macOS signing script  
      - name: Create macOS signing script
        run: |
          mkdir -p scripts
          cat > scripts/sign-macos.js << 'EOF'
          #!/usr/bin/env node
          const { execSync } = require('child_process');
          const path = require('path');
          
          async function signMacOS(appPath) {
            console.log('🔐 Ad-hoc signing macOS app:', path.basename(appPath));
            
            try {
              // Ad-hoc sign the app and all nested executables
              execSync(`codesign --force --deep --sign - "${appPath}"`, { stdio: 'inherit' });
              
              // Sign specific binaries if they exist
              const binaries = ['whisper-cli', 'diarize-cli'];
              for (const binary of binaries) {
                const binaryPath = path.join(appPath, 'Contents', 'Resources', 'binaries', binary);
                try {
                  execSync(`codesign --force --sign - "${binaryPath}"`, { stdio: 'pipe' });
                  console.log(`✅ Signed binary: ${binary}`);
                } catch (e) {
                  console.log(`ℹ️ Binary not found or already signed: ${binary}`);
                }
              }
              
              console.log('✅ macOS app ad-hoc signed successfully');
            } catch (error) {
              console.warn('⚠️ macOS signing failed (non-critical):', error.message);
            }
          }
          
          // CLI usage
          if (require.main === module) {
            const appPath = process.argv[2];
            if (appPath) {
              signMacOS(appPath);
            }
          }
          
          module.exports = signMacOS;
          EOF
          
          chmod +x scripts/sign-macos.js
          echo "✅ macOS signing script created"

      # 🔴 MODIFIED: Build Electron app (macOS) - Add post-build signing
      - name: Build Electron app
        env:
          CSC_IDENTITY_AUTO_DISCOVERY: false
        run: |
          echo "🔧 Building Electron app for macOS ${{ matrix.arch }}..."
          
          # Build the app
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            npx electron-builder --mac --arm64 --publish=never
          else
            npx electron-builder --mac --x64 --publish=never
          fi
          
          # 🔐 NEW: Post-build ad-hoc signing
          echo "🔐 Applying ad-hoc signatures to macOS app..."
          
          # Find the built app
          APP_PATH=$(find dist -name "*.app" -type d | head -1)
          if [ -n "$APP_PATH" ]; then
            echo "Found app: $APP_PATH"
            node scripts/sign-macos.js "$APP_PATH"
          else
            echo "⚠️ No .app found for signing"
          fi
          
          # Rename ZIP files to Portable versions
          node scripts/rename-portable.js
          
          echo "✅ macOS build completed"

      # 🔐 NEW: Verify Code Signing
      - name: Verify Code Signing
        shell: bash
        run: |
          echo "🔍 Verifying code signing status..."
          
          if [ "${{ runner.os }}" = "macOS" ]; then
            # Check macOS app signatures
            for app in dist/*.app; do
              if [ -d "$app" ]; then
                echo "Checking: $(basename "$app")"
                if codesign -v "$app" 2>/dev/null; then
                  echo "✅ Signed: $(basename "$app")"
                else
                  echo "⚠️ Signature issue: $(basename "$app")"
                fi
              fi
            done
            
            # Check ZIP contents if they contain apps
            for zip in dist/*.zip; do
              if [ -f "$zip" ]; then
                echo "ℹ️ ZIP archive: $(basename "$zip")"
              fi
            done
          fi

      # Upload artifacts
      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: WhisperDesk-macos-${{ matrix.arch }}
          path: |
            dist/*.zip
          retention-days: 30

  # Linux build (with diarization)
  build-linux:
    runs-on: ubuntu-22.04
    needs: [determine-version]

    strategy:
      matrix:
        arch: [x64]
        build_type: [Release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake libasound2-dev fuse libfuse2

      - name: Update main package.json version
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          echo "🏷️ Setting main package.json version to: $VERSION"
          
          if [ -f "package.json" ]; then
            cat package.json | jq --arg version "$VERSION" '
              .version = $version |
              .main = "src/main/main.js" |
              .build.appId = "com.whisperdesk.enhanced" |
              .build.productName = "WhisperDesk" |
              .build.directories.output = "dist" |
              .build.files = [
                "src/**/*",
                "binaries/**/*",
                "models/**/*", 
                "!binaries/models/**/*",
                "package.json"
              ] |
              .build.extraResources = [
                {"from": "binaries/", "to": "binaries/", "filter": ["**/*"]}
              ] |
              .build.linux = {
                "target": [
                  {"target": "AppImage", "arch": ["x64"]},
                  {"target": "deb", "arch": ["x64"]},
                  {"target": "rpm", "arch": ["x64"]},
                  {"target": "tar.gz", "arch": ["x64"]}
                ],
                "icon": "resources/icons/icon.png"
              }
            ' > package.json.tmp && mv package.json.tmp package.json
            echo "✅ Updated main package.json"
          fi

      - name: Install main dependencies
        env:
          CI: true
          GITHUB_ACTIONS: true
          npm_config_ignore_scripts: true
        run: npm install

      - name: Install renderer dependencies
        run: |
          if [ -d "src/renderer/whisperdesk-ui" ]; then
            cd src/renderer/whisperdesk-ui
            
            if [ -f "package.json" ]; then
              VERSION="${{ needs.determine-version.outputs.version }}"
              cat package.json | jq --arg version "$VERSION" '.version = $version' > package.json.tmp
              mv package.json.tmp package.json
              echo "✅ Updated renderer package.json version"
            fi
            
            pnpm install --frozen-lockfile
          fi

      - name: Build whisper.cpp (via script)
        run: npm run build:whisper
        shell: bash

      # 🔴 NEW: Build enhanced diarization system for Linux
      - name: Build enhanced diarization system
        run: |
          echo "🎭 Building enhanced multi-speaker diarization system for Linux..."
          if npm run build:diarization; then
            echo "✅ Diarization build completed successfully"
          else
            echo "⚠️ Diarization build failed - multi-speaker detection will be disabled"
            # Don't fail the entire build
          fi
        shell: bash

      # Verify diarization build
      - name: Verify diarization build
        run: |
          DIARIZE_BIN="binaries/diarize-cli"
          if [ -f "$DIARIZE_BIN" ]; then
            echo "✅ Diarization binary found: $DIARIZE_BIN"
            chmod +x "$DIARIZE_BIN"
            ls -la "$DIARIZE_BIN"
            echo "📊 Binary size: $(ls -lh $DIARIZE_BIN | awk '{print $5}')"
            
            # Check for required models
            if [ -f "models/segmentation-3.0.onnx" ]; then
              echo "✅ Segmentation model found ($(ls -lh models/segmentation-3.0.onnx | awk '{print $5}'))"
            else
              echo "⚠️ Segmentation model missing"
            fi
            
            if [ -f "models/embedding-1.0.onnx" ]; then
              echo "✅ Embedding model found ($(ls -lh models/embedding-1.0.onnx | awk '{print $5}'))"
            else
              echo "⚠️ Embedding model missing"
            fi
            
            # Check library dependencies on Linux
            echo "🔗 Library dependencies:"
            ldd "$DIARIZE_BIN" || echo "Could not check dependencies"
            
          else
            echo "⚠️ Diarization binary not found - single speaker mode only"
          fi
        shell: bash

      # Download tiny model
      - name: Download tiny model
        run: |
          mkdir -p models
          curl -L -o models/ggml-tiny.bin https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin

      # Build renderer
      - name: Build renderer
        run: |
          if [ -d "src/renderer/whisperdesk-ui" ]; then
            cd src/renderer/whisperdesk-ui
            pnpm run build
          fi

      # Verify build prerequisites
      - name: Verify build prerequisites
        run: |
          echo "📋 Verifying all build prerequisites..."
          
          # Check main entry point
          if [ -f "src/main/main.js" ]; then
            echo "✅ Main entry point: src/main/main.js"
          else
            echo "❌ CRITICAL: Main entry point missing"
            exit 1
          fi
          
          # Check binary exists and is executable
          BINARY_PATH="binaries/whisper-cli"
          if [ -f "$BINARY_PATH" ] && [ -x "$BINARY_PATH" ]; then
            echo "✅ whisper-cli binary found and executable"
            echo "📊 Size: $(ls -lh $BINARY_PATH | awk '{print $5}')"
          else
            echo "❌ whisper-cli binary missing or not executable"
            exit 1
          fi
          
          # Check model exists
          if [ -f "models/ggml-tiny.bin" ]; then
            echo "✅ Model ready"
          else
            echo "❌ Model missing"
            exit 1
          fi
          
          # Check renderer build
          if [ -d "src/renderer/whisperdesk-ui/dist" ]; then
            echo "✅ Renderer ready"
          else
            echo "❌ Renderer missing"
            exit 1
          fi

      # 🔴 FIXED: Simplified electron-builder for Linux
      - name: Build Electron app
        run: |
          echo "🔧 Building Electron app for Linux..."
          
          # FIXED: Much simpler command
          npx electron-builder --linux --x64 --publish=never
          
          # Rename any ZIP files to Portable versions
          node scripts/rename-portable.js
          
          echo "✅ Linux build completed"

      # Upload artifacts
      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: WhisperDesk-linux-${{ matrix.arch }}
          path: |
            dist/*.AppImage
            dist/*.deb
            dist/*.rpm
            dist/*.tar.gz
          retention-days: 30

  # Create release
  create-release:
    if: startsWith(github.ref, 'refs/tags/v') || github.event.inputs.create_release == 'true' || needs.determine-version.outputs.tag_name == 'dev'
    needs: [determine-version, build-windows, build-macos, build-linux]
    runs-on: ubuntu-latest

    permissions:
      contents: write
      actions: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Organize release files
        run: |
          echo "🔧 Organizing release files..."
          mkdir -p release-files
          
          find artifacts/ -type f \( -name "*.exe" -o -name "*.zip" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" -o -name "*.tar.gz" \) -exec cp {} release-files/ \;
          
          echo "📋 Release files:"
          ls -la release-files/

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: release-files/*
          draft: false
          prerelease: ${{ contains(needs.determine-version.outputs.version, 'dev') }}
          generate_release_notes: true
          name: "WhisperDesk ${{ needs.determine-version.outputs.tag_name }}"
          tag_name: ${{ needs.determine-version.outputs.tag_name }}
          body: |
            ## WhisperDesk ${{ needs.determine-version.outputs.tag_name }}
            
            🎉 **Enhanced Release with Multi-Speaker Diarization!**
            
            ### 📦 Download Options:
            
            **🖥️ Windows (64-bit)**:
            - `WhisperDesk-Setup-${{ needs.determine-version.outputs.file_version }}-win-x64.exe` - Installer (recommended)
            - `WhisperDesk-Portable-${{ needs.determine-version.outputs.file_version }}-win-x64.zip` - **True Portable** (extract and run)
            
            **🍎 macOS**:
            - `WhisperDesk-Portable-${{ needs.determine-version.outputs.file_version }}-mac-x64.zip` - Intel Mac portable
            - `WhisperDesk-Portable-${{ needs.determine-version.outputs.file_version }}-mac-arm64.zip` - Apple Silicon portable
            
            **🐧 Linux (64-bit)**:
            - `WhisperDesk-${{ needs.determine-version.outputs.file_version }}-linux-x64.AppImage` - Portable (recommended)
            - `WhisperDesk-${{ needs.determine-version.outputs.file_version }}-linux-x64.deb` - Debian/Ubuntu package
            - `WhisperDesk-${{ needs.determine-version.outputs.file_version }}-linux-x64.rpm` - Red Hat/Fedora package
            - `WhisperDesk-${{ needs.determine-version.outputs.file_version }}-linux-x64.tar.gz` - Generic archive
            
            ### ✨ NEW: Enhanced Multi-Speaker Features:
            - 🎭 **Advanced Speaker Diarization** - Built-in PyAnnote 3.0 ONNX models
            - 👥 **Multi-Speaker Detection** - Automatic speaker identification and labeling
            - 🎚️ **Configurable Sensitivity** - Adjust speaker detection threshold (0.001-0.1)
            - 📊 **Speaker Statistics** - Detailed analytics per speaker
            - 🌍 **Cross-Platform ONNX** - Consistent results across Windows, macOS, Linux
            
            ### 🔧 Core Features:
            - 🎵 Native whisper.cpp integration with **whisper-cli** binary
            - 📱 Cross-platform support (Windows, macOS, Linux)
            - 🔄 Real-time progress tracking
            - 💾 Persistent state management
            - 🎯 Multiple model support (Tiny, Base, Small, Medium, Large)
            - 📁 Drag & drop file upload
            - 🎨 Modern, responsive UI
            
            ### 🎭 Multi-Speaker Usage:
            1. **Enable Speaker Diarization** in transcription settings
            2. **Adjust Sensitivity**:
               - High sensitivity (0.001-0.01): Detects 3+ speakers
               - Normal sensitivity (0.01-0.05): Balanced detection
               - Low sensitivity (0.05-0.1): Conservative, 1-2 speakers
            3. **Review Results** with speaker labels and statistics
            
            ### 🚀 Quick Start:
            1. **Download** the appropriate file for your platform
            2. **Windows Portable**: Extract the ZIP file and run `WhisperDesk.exe`
            3. **Install Models**: Download a model in the Models tab (start with Tiny)
            4. **Enable Multi-Speaker**: Toggle "Speaker Diarization" in settings
            5. **Start Transcribing** with automatic speaker detection!
            
            ### 🔧 Technical Updates:
            - **Enhanced Diarization Engine**: Cross-platform C++ implementation
            - **ONNX Runtime Integration**: Consistent AI model execution
            - **PyAnnote 3.0 Models**: State-of-the-art speaker segmentation and embedding
            - **Improved Build System**: Automatic diarization binary compilation
            - **Better Error Handling**: Graceful fallback to single-speaker mode
            
            ---
            
            **Technical Details:**
            - Version: ${{ needs.determine-version.outputs.version }}
            - Whisper Binary: whisper-cli (official, replaces deprecated main.exe)
            - Diarization: PyAnnote 3.0 ONNX models with cross-platform C++ engine
            - Build: CMake + electron-builder + official whisper.cpp + enhanced diarization
            
            Auto-generated release notes below ⬇️
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}