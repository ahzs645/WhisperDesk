# .github/workflows/main.yml - FIXED with correct binary detection
name: Build WhisperDesk for All Platforms

on:
  push:
    branches: [ main, release ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

permissions:
  contents: write
  actions: read
  checks: write
  pull-requests: write

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: darwin
            arch: x64
            artifact: WhisperDesk-mac-x64
            electron_arch: x64
            electron_target: --mac --x64
          - os: macos-latest
            platform: darwin
            arch: arm64
            artifact: WhisperDesk-mac-arm64
            electron_arch: arm64
            electron_target: --mac --arm64
          - os: ubuntu-latest
            platform: linux
            arch: x64
            artifact: WhisperDesk-linux-x64
            electron_arch: x64
            electron_target: --linux --x64
          - os: windows-latest
            platform: win32
            arch: x64
            artifact: WhisperDesk-windows-x64
            electron_arch: x64
            electron_target: --win --x64

    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Setup pnpm
      uses: pnpm/action-setup@v4
      with:
        version: latest

    # Platform-specific dependencies
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake libasound2-dev
        sudo apt-get install -y fuse libfuse2

    - name: Install macOS dependencies
      if: runner.os == 'macOS'
      run: |
        # Install Xcode command line tools if not present
        xcode-select --install || true
        # Install cmake via homebrew
        brew install cmake

    - name: Add MSBuild to PATH (Windows)
      if: runner.os == 'Windows'
      uses: microsoft/setup-msbuild@v2

    # Extract version from tag and update package.json
    - name: Set version from tag
      shell: bash
      run: |
        if [ "${{ github.ref_type }}" = "tag" ]; then
          # Extract version from tag (remove 'v' prefix)
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix if present
          
          echo "ğŸ·ï¸ Setting version to: $VERSION"
          
          # Update main package.json
          if command -v jq &> /dev/null; then
            # Use jq if available
            jq --arg version "$VERSION" '.version = $version' package.json > package.json.tmp && mv package.json.tmp package.json
          else
            # Fallback to sed
            sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
          fi
          
          echo "âœ… Updated main package.json version to: $VERSION"
          grep '"version"' package.json
          
          # Also set as environment variable for electron-builder
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
        else
          echo "ğŸ”§ Not a tag build, keeping existing version"
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "APP_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
        fi

    # Install main dependencies
    - name: Install main dependencies
      run: npm install

    # Install renderer dependencies
    - name: Install renderer dependencies
      shell: bash
      run: |
        cd src/renderer/whisperdesk-ui
        
        # Update renderer package.json version if this is a tag build
        if [ "${{ github.ref_type }}" = "tag" ]; then
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"
          
          echo "ğŸ·ï¸ Updating renderer package.json version to: $VERSION"
          
          if command -v jq &> /dev/null; then
            jq --arg version "$VERSION" '.version = $version' package.json > package.json.tmp && mv package.json.tmp package.json
          else
            sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
          fi
          
          echo "âœ… Updated renderer package.json version"
          grep '"version"' package.json
        fi
        
        pnpm install --frozen-lockfile

    # Build whisper.cpp from source - UNIX platforms - FIXED binary detection
    - name: Build whisper.cpp (Linux/macOS) - FIXED binary detection
      if: runner.os != 'Windows'
      run: |
        echo "ğŸ”¨ Building whisper.cpp with cmake for Unix platforms..."
        
        # Clone whisper.cpp from OFFICIAL repository
        git clone https://github.com/ggml-org/whisper.cpp.git /tmp/whisper.cpp
        cd /tmp/whisper.cpp
        
        # Use modern cmake build approach
        cmake -B build -DCMAKE_BUILD_TYPE=Release
        cmake --build build --config Release --parallel $(nproc 2>/dev/null || sysctl -n hw.ncpu || echo 4)
        
        # FIXED: Updated binary search with correct 2025 naming
        echo "ğŸ” Searching for whisper binary with correct naming..."
        
        # Current whisper.cpp binary names (as of 2025)
        BINARY_NAMES=("whisper-cli" "main")
        BUILD_DIRS=("build/bin" "bin" "build")
        
        WHISPER_BINARY=""
        
        for name in "${BINARY_NAMES[@]}"; do
          for dir in "${BUILD_DIRS[@]}"; do
            candidate="${dir}/${name}"
            if [ -f "$candidate" ]; then
              # Check if binary is a working binary (not a stub)
              echo "ğŸ§ª Testing binary: $candidate"
              
              # Test the binary to ensure it's not a deprecated stub
              if timeout 10s "$candidate" --help > test_output.txt 2> test_error.txt; then
                # Check output and error for deprecation warnings
                if grep -q "deprecated" test_error.txt 2>/dev/null; then
                  echo "âš ï¸ Found deprecated binary: $candidate"
                  # Extract recommended binary name from deprecation message
                  RECOMMENDED=$(grep -o "Please use '[^']*'" test_error.txt | sed "s/Please use '//;s/'//")
                  if [ -n "$RECOMMENDED" ]; then
                    echo "ğŸ” Looking for recommended binary: $RECOMMENDED"
                    for search_dir in "${BUILD_DIRS[@]}"; do
                      recommended_path="${search_dir}/${RECOMMENDED}"
                      if [ -f "$recommended_path" ]; then
                        WHISPER_BINARY="$recommended_path"
                        echo "âœ… Found recommended binary: $WHISPER_BINARY"
                        break 3  # Break all loops
                      fi
                    done
                  fi
                else
                  WHISPER_BINARY="$candidate"
                  echo "âœ… Found working binary: $WHISPER_BINARY"
                  break 2  # Break outer loops
                fi
              else
                echo "âš ï¸ Binary test failed for: $candidate"
              fi
            fi
          done
        done
        
        # Clean up test files
        rm -f test_output.txt test_error.txt
        
        if [ -z "$WHISPER_BINARY" ]; then
          echo "âŒ Could not find any working whisper binary"
          echo "ğŸ“‹ Available files in build directories:"
          for dir in "${BUILD_DIRS[@]}"; do
            if [ -d "$dir" ]; then
              echo "Directory: $dir"
              ls -la "$dir" 2>/dev/null || echo "  (empty or inaccessible)"
            fi
          done
          exit 1
        fi
        
        # Copy to project binaries directory with standard name
        mkdir -p "$GITHUB_WORKSPACE/binaries"
        cp "$WHISPER_BINARY" "$GITHUB_WORKSPACE/binaries/whisper"
        chmod +x "$GITHUB_WORKSPACE/binaries/whisper"
        
        echo "âœ… whisper.cpp built and installed successfully"
        echo "ğŸ“ Final binary: $GITHUB_WORKSPACE/binaries/whisper"

    # Build whisper.cpp from source - Windows - FIXED binary detection
    - name: Build whisper.cpp (Windows) - FIXED binary detection
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "ğŸ”¨ Building whisper.cpp for Windows..." -ForegroundColor Green
        
        # Clone whisper.cpp from OFFICIAL repository
        git clone https://github.com/ggml-org/whisper.cpp.git C:\temp\whisper.cpp
        Set-Location C:\temp\whisper.cpp
        
        Write-Host "âœ… Cloned whisper.cpp from official repository"
        
        # Configure with MSVC
        cmake -S . -B ./build -A x64 -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON
        
        Write-Host "âœ… Configured with MSVC"
        
        # Build using MSBuild
        Set-Location build
        msbuild ALL_BUILD.vcxproj -t:build -p:configuration=Release -p:platform=x64
        
        Write-Host "âœ… Built with MSBuild"
        
        # FIXED: Updated binary search with correct 2025 naming and better testing
        $buildDirs = @("bin\Release", "Release", "bin")
        # Current whisper.cpp binary names (as of 2025)
        $binaryNames = @("whisper-cli.exe", "main.exe")
        
        $foundBinary = $null
        $foundPath = ""
        
        Write-Host "ğŸ” Searching for whisper binary with correct naming: $($binaryNames -join ', ')"
        
        foreach ($dir in $buildDirs) {
            if (-not (Test-Path $dir)) { continue }
            
            foreach ($name in $binaryNames) {
                $candidate = Join-Path $dir $name
                if (Test-Path $candidate) {
                    Write-Host "ğŸ” Found candidate binary: $candidate"
                    
                    # Check file size to ensure it's not a stub
                    $fileInfo = Get-Item $candidate
                    $size = $fileInfo.Length
                    Write-Host "ğŸ“Š Binary size: $size bytes"
                    
                    # Modern whisper-cli binaries should be at least 500KB
                    if ($size -lt 500000) {
                        Write-Host "âš ï¸ Binary too small ($size bytes) - likely a stub, skipping" -ForegroundColor Yellow
                        continue
                    }
                    
                    Write-Host "ğŸ§ª Testing binary: $candidate"
                    
                    # Test the binary with simple checks that don't require models
                    $isWorkingBinary = $false
                    $recommendedBinary = ""
                    
                    try {
                        # Try --version first, then --help if that fails
                        $versionProcess = Start-Process -FilePath $candidate -ArgumentList "--version" -Wait -NoNewWindow -PassThru -RedirectStandardOutput "test_output.txt" -RedirectStandardError "test_error.txt" -TimeoutSec 5
                        
                        if ($versionProcess.ExitCode -ne 0) {
                            # Try --help if --version failed
                            $helpProcess = Start-Process -FilePath $candidate -ArgumentList "--help" -Wait -NoNewWindow -PassThru -RedirectStandardOutput "test_output.txt" -RedirectStandardError "test_error.txt" -TimeoutSec 5
                        }
                        
                        # Check if we got any output
                        $hasOutput = $false
                        if (Test-Path "test_output.txt") {
                            $outputContent = Get-Content "test_output.txt" -Raw -ErrorAction SilentlyContinue
                            if ($outputContent.Length -gt 0) { $hasOutput = $true }
                        }
                        if (Test-Path "test_error.txt") {
                            $errorContent = Get-Content "test_error.txt" -Raw -ErrorAction SilentlyContinue
                            if ($errorContent.Length -gt 0) { $hasOutput = $true }
                            
                            # Check for deprecation warning
                            if ($errorContent -match "deprecated") {
                                Write-Host "âš ï¸ Found deprecated binary: $candidate" -ForegroundColor Yellow
                                
                                # Extract recommended binary name
                                if ($errorContent -match "Please use '([^']+)'") {
                                    $recommendedBinary = $matches[1]
                                    Write-Host "ğŸ” Looking for recommended binary: $recommendedBinary" -ForegroundColor Yellow
                                    
                                    # Search for the recommended binary
                                    foreach ($searchDir in $buildDirs) {
                                        $recommendedPath = Join-Path $searchDir $recommendedBinary
                                        if (Test-Path $recommendedPath) {
                                            $foundPath = $recommendedPath
                                            $foundBinary = $recommendedBinary
                                            $isWorkingBinary = $true
                                            Write-Host "âœ… Found recommended binary: $foundPath" -ForegroundColor Green
                                            break
                                        }
                                    }
                                }
                            }
                        }
                        
                        # If we have output and no deprecation issues, consider it working
                        if ($hasOutput -and -not $isWorkingBinary) {
                            $foundPath = $candidate
                            $foundBinary = $name
                            $isWorkingBinary = $true
                            Write-Host "âœ… Found working binary: $foundPath" -ForegroundColor Green
                        } elseif (-not $hasOutput -and -not $isWorkingBinary) {
                            Write-Host "âš ï¸ Binary produced no output: $candidate" -ForegroundColor Yellow
                            # Keep as fallback if size is good and no better option found
                            if (-not $foundBinary) {
                                Write-Host "ğŸ’¡ Keeping as fallback option since size looks good" -ForegroundColor Cyan
                                $foundPath = $candidate
                                $foundBinary = $name
                                $isWorkingBinary = $true
                            }
                        }
                        
                    } catch {
                        Write-Host "âš ï¸ Binary test timeout or failed for: $candidate - $($_.Exception.Message)" -ForegroundColor Yellow
                        # Keep as fallback if no other option and size is reasonable
                        if (-not $foundBinary) {
                            Write-Host "ğŸ’¡ Keeping as fallback option since size looks good" -ForegroundColor Cyan
                            $foundPath = $candidate
                            $foundBinary = $name
                            $isWorkingBinary = $true
                        }
                    } finally {
                        # Clean up test files
                        Remove-Item "test_output.txt" -ErrorAction SilentlyContinue
                        Remove-Item "test_error.txt" -ErrorAction SilentlyContinue
                    }
                    
                    if ($isWorkingBinary) {
                        break
                    }
                }
            }
            if ($foundBinary) { break }
        }
        
        if (-not $foundBinary) {
            Write-Host "âŒ Could not find any working whisper binary" -ForegroundColor Red
            Write-Host "ğŸ“‹ Available files in build directories:" -ForegroundColor Yellow
            foreach ($dir in $buildDirs) {
                if (Test-Path $dir) {
                    Write-Host "Directory: $dir" -ForegroundColor Cyan
                    Get-ChildItem $dir -Filter "*.exe" -ErrorAction SilentlyContinue | Select-Object Name, Length | Format-Table
                }
            }
            exit 1
        }
        
        # Create target directory and copy binary
        $targetDir = "$env:GITHUB_WORKSPACE\binaries"
        New-Item -ItemType Directory -Force -Path $targetDir | Out-Null
        
        # Copy the found binary as whisper.exe (standard name for the app)
        Copy-Item $foundPath "$targetDir\whisper.exe" -Force
        Write-Host "âœ… Copied binary: $foundPath -> whisper.exe" -ForegroundColor Green
        
        # Copy all DLLs from the build directory
        $buildDir = Split-Path $foundPath -Parent
        $dlls = Get-ChildItem -Path $buildDir -Filter "*.dll" -ErrorAction SilentlyContinue
        
        if ($dlls.Count -gt 0) {
            foreach ($dll in $dlls) {
                Copy-Item $dll.FullName $targetDir -Force
                Write-Host "âœ… Copied DLL: $($dll.Name)" -ForegroundColor Green
            }
            Write-Host "ğŸ“‹ Total DLLs copied: $($dlls.Count)" -ForegroundColor Cyan
        } else {
            Write-Host "âš ï¸ No DLLs found in build directory: $buildDir" -ForegroundColor Yellow
        }
        
        Write-Host "âœ… whisper.cpp built and installed successfully" -ForegroundColor Green
        Write-Host "ğŸ“ Final binary: $targetDir\whisper.exe" -ForegroundColor Cyan

    # Package Visual C++ Runtime Dependencies (Windows)
    - name: Package VC++ Runtime (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "ğŸ“¦ Packaging Visual C++ Runtime Dependencies..." -ForegroundColor Green
        
        $targetDir = "$env:GITHUB_WORKSPACE\binaries"
        
        # Download VC++ Redistributable for users who need it
        $vcredistUrl = "https://aka.ms/vs/17/release/vc_redist.x64.exe"
        $vcredistPath = "$targetDir\vc_redist.x64.exe"
        
        try {
            Write-Host "â¬‡ï¸ Downloading VC++ Redistributable..."
            Invoke-WebRequest -Uri $vcredistUrl -OutFile $vcredistPath -UseBasicParsing
            Write-Host "âœ… Downloaded VC++ Redistributable installer"
        } catch {
            Write-Host "âš ï¸ Failed to download VC++ Redistributable: $($_.Exception.Message)"
        }
        
        # Try to copy runtime DLLs from system
        $runtimeDlls = @(
            @{ Name = "msvcp140.dll"; Path = "C:\Windows\System32\msvcp140.dll" },
            @{ Name = "vcruntime140.dll"; Path = "C:\Windows\System32\vcruntime140.dll" },
            @{ Name = "vcruntime140_1.dll"; Path = "C:\Windows\System32\vcruntime140_1.dll" },
            @{ Name = "vcomp140.dll"; Path = "C:\Windows\System32\vcomp140.dll" }
        )
        
        foreach ($dll in $runtimeDlls) {
            if (Test-Path $dll.Path) {
                try {
                    Copy-Item $dll.Path $targetDir -Force
                    Write-Host "âœ… Copied runtime DLL: $($dll.Name)"
                } catch {
                    Write-Host "âš ï¸ Could not copy $($dll.Name): $($_.Exception.Message)"
                }
            } else {
                Write-Host "âš ï¸ Runtime DLL not found: $($dll.Name)"
            }
        }

    # Enhanced binary verification - FIXED
    - name: Enhanced binary verification
      shell: bash
      run: |
        echo "ğŸ” Enhanced binary verification..."
        
        if [ "${{ runner.os }}" = "Windows" ]; then
          BINARY_PATH="binaries/whisper.exe"
        else
          BINARY_PATH="binaries/whisper"
        fi
        
        if [ -f "$BINARY_PATH" ]; then
          echo "âœ… Binary exists: $BINARY_PATH"
          ls -la "$BINARY_PATH"
          
          # Get file size to detect stubs
          if [ "${{ runner.os }}" = "Windows" ]; then
            SIZE=$(powershell -Command "(Get-Item '$BINARY_PATH').Length")
          else
            SIZE=$(stat -c%s "$BINARY_PATH" 2>/dev/null || stat -f%z "$BINARY_PATH")
          fi
          
          echo "ğŸ“Š Binary size: $SIZE bytes"
          
          # FIXED: Updated size check for modern whisper.cpp binaries  
          # Modern whisper-cli binaries are typically 500KB+ (much larger than old stubs)
          if [ "$SIZE" -lt 300000 ]; then
            echo "âŒ ERROR: Binary is suspiciously small ($SIZE bytes) - likely a stub!"
            echo "ğŸ” Modern whisper-cli binaries should be 300KB+ in size"
            
            # List all executables in binaries directory for debugging
            echo "ğŸ“‹ All executables in binaries directory:"
            if [ "${{ runner.os }}" = "Windows" ]; then
              powershell -Command "Get-ChildItem binaries -Filter '*.exe' | Format-Table Name, Length"
            else
              find binaries -type f -executable -exec ls -la {} \;
            fi
            
            echo "âŒ BUILD FAILED: Binary too small - likely a stub"
            exit 1
          else
            echo "âœ… Binary size looks good ($SIZE bytes)"
          fi
          
        else
          echo "âŒ Binary not found at: $BINARY_PATH"
          echo "ğŸ“‹ Contents of binaries directory:"
          ls -la binaries/ || echo "No binaries directory"
          exit 1
        fi

    # Download tiny model for inclusion
    - name: Download tiny model
      run: |
        mkdir -p models
        curl -L -o models/ggml-tiny.bin https://huggingface.co/ggerganov/whisper.cpp/resolve/main/ggml-tiny.bin

    # Build renderer
    - name: Build renderer
      run: |
        cd src/renderer/whisperdesk-ui
        pnpm run build

    # Configure electron-builder with FIXED binary packaging
    - name: Configure electron-builder (Unix) - FIXED
      if: runner.os != 'Windows'
      run: |
        echo "ğŸ”§ Configuring electron-builder with BINARY PACKAGING and platform-specific naming..."
        
        # Create electron-builder config with proper binary packaging and unique naming
        cat > electron-builder-fixed.json << 'EOF'
        {
          "appId": "com.yourcompany.whisperdesk",
          "productName": "WhisperDesk Enhanced",
          "directories": {
            "output": "dist"
          },
          "artifactName": "${productName}-${version}-${os}-${arch}.${ext}",
          "files": [
            "src/main/**/*",
            "src/renderer/whisperdesk-ui/dist/**/*",
            "src/shared/**/*",
            "node_modules/**/*",
            "package.json"
          ],
          "extraResources": [
            {
              "from": "binaries/",
              "to": "binaries/",
              "filter": ["**/*"]
            },
            {
              "from": "models/",
              "to": "models/",
              "filter": ["**/*"]
            }
          ],
          "win": {
            "target": [
              {
                "target": "nsis",
                "arch": ["x64"]
              },
              {
                "target": "zip",
                "arch": ["x64"]
              }
            ],
            "publisherName": "WhisperDesk Team",
            "verifyUpdateCodeSignature": false
          },
          "mac": {
            "target": [
              {
                "target": "dmg",
                "arch": ["x64", "arm64"]
              },
              {
                "target": "zip",
                "arch": ["x64", "arm64"]
              }
            ],
            "category": "public.app-category.productivity",
            "hardenedRuntime": true,
            "gatekeeperAssess": false
          },
          "linux": {
            "target": [
              {
                "target": "AppImage",
                "arch": ["x64"]
              },
              {
                "target": "deb",
                "arch": ["x64"]
              },
              {
                "target": "rpm",
                "arch": ["x64"]
              },
              {
                "target": "tar.gz",
                "arch": ["x64"]
              }
            ],
            "category": "AudioVideo"
          }
        }
        EOF
        
        echo "âœ… Electron-builder configuration created with PLATFORM-SPECIFIC NAMING"

    - name: Configure electron-builder (Windows) - FIXED
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "ğŸ”§ Configuring electron-builder with BINARY PACKAGING and platform-specific naming..."
        
        # Create electron-builder config with proper binary packaging
        $config = @"
        {
          "appId": "com.yourcompany.whisperdesk",
          "productName": "WhisperDesk Enhanced",
          "directories": {
            "output": "dist"
          },
          "artifactName": "`${productName}-`${version}-`${os}-`${arch}.`${ext}",
          "files": [
            "src/main/**/*",
            "src/renderer/whisperdesk-ui/dist/**/*",
            "src/shared/**/*",
            "node_modules/**/*",
            "package.json"
          ],
          "extraResources": [
            {
              "from": "binaries/",
              "to": "binaries/",
              "filter": ["**/*"]
            },
            {
              "from": "models/",
              "to": "models/",
              "filter": ["**/*"]
            }
          ],
          "win": {
            "target": [
              {
                "target": "nsis",
                "arch": ["x64"]
              },
              {
                "target": "zip",
                "arch": ["x64"]
              }
            ],
            "publisherName": "WhisperDesk Team",
            "verifyUpdateCodeSignature": false
          },
          "mac": {
            "target": [
              {
                "target": "dmg",
                "arch": ["x64", "arm64"]
              },
              {
                "target": "zip",
                "arch": ["x64", "arm64"]
              }
            ],
            "category": "public.app-category.productivity",
            "hardenedRuntime": true,
            "gatekeeperAssess": false
          },
          "linux": {
            "target": [
              {
                "target": "AppImage",
                "arch": ["x64"]
              },
              {
                "target": "deb",
                "arch": ["x64"]
              },
              {
                "target": "rpm",
                "arch": ["x64"]
              },
              {
                "target": "tar.gz",
                "arch": ["x64"]
              }
            ],
            "category": "AudioVideo"
          }
        }
        "@
        
        # Write to file
        $config | Out-File -FilePath "electron-builder-fixed.json" -Encoding UTF8
        
        Write-Host "âœ… Electron-builder configuration created with PLATFORM-SPECIFIC NAMING"

    # Verify version before building
    - name: Verify version configuration
      shell: bash
      run: |
        echo "ğŸ” Verifying version configuration..."
        echo "ğŸ“‹ Git ref: ${{ github.ref }}"
        echo "ğŸ“‹ Git ref type: ${{ github.ref_type }}"
        echo "ğŸ“‹ Git ref name: ${{ github.ref_name }}"
        echo "ğŸ“‹ App version (env): $APP_VERSION"
        echo "ğŸ“‹ Package.json version: $(node -p "require('./package.json').version")"
        
        # Verify versions match
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        if [ "$APP_VERSION" != "$PACKAGE_VERSION" ]; then
          echo "âš ï¸ Warning: Environment version ($APP_VERSION) differs from package.json ($PACKAGE_VERSION)"
        else
          echo "âœ… Version consistency verified: $APP_VERSION"
        fi

    # Build Electron app for specific platform
    - name: Build Electron app (macOS)
      if: matrix.platform == 'darwin'
      env:
        CSC_IDENTITY_AUTO_DISCOVERY: false
      run: |
        npm run build:skip-whisper
        npx electron-builder ${{ matrix.electron_target }} --publish=never --config electron-builder-fixed.json

    - name: Build Electron app (Linux)
      if: matrix.platform == 'linux'
      run: |
        npm run build:skip-whisper
        npx electron-builder ${{ matrix.electron_target }} --publish=never --config electron-builder-fixed.json

    - name: Build Electron app (Windows)
      if: matrix.platform == 'win32'
      env:
        CSC_IDENTITY_AUTO_DISCOVERY: false
      run: |
        npm run build:skip-whisper
        npx electron-builder ${{ matrix.electron_target }} --publish=never --config electron-builder-fixed.json

    # VERIFY: Check for unwanted ia32 builds
    - name: Verify no ia32 builds created
      shell: bash
      run: |
        echo "ğŸ” Checking for unwanted ia32/32-bit builds..."
        
        # Check for ia32 in filenames
        if find dist/ -name "*ia32*" 2>/dev/null | grep -q .; then
          echo "âŒ ERROR: Found ia32 builds when only x64 was expected!"
          find dist/ -name "*ia32*"
          exit 1
        else
          echo "âœ… No ia32 builds found - good!"
        fi
        
        # List all built files for verification
        echo "ğŸ“‹ Built files:"
        find dist/ -type f -name "*.exe" -o -name "*.dmg" -o -name "*.zip" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" -o -name "*.tar.gz" | sort

    # Upload artifacts with clear platform separation
    - name: Upload macOS artifacts
      if: matrix.platform == 'darwin'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          dist/*.dmg
          dist/*.zip
        retention-days: 30

    - name: Upload Linux artifacts
      if: matrix.platform == 'linux'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          dist/*.AppImage
          dist/*.deb
          dist/*.rpm
          dist/*.tar.gz
        retention-days: 30

    - name: Upload Windows artifacts
      if: matrix.platform == 'win32'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact }}
        path: |
          dist/*.exe
          dist/*.zip
        retention-days: 30

  # Create release with proper file organization
  release:
    if: startsWith(github.ref, 'refs/tags/v')
    needs: build
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      actions: read
      id-token: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Set clean version for release notes
      id: version
      run: |
        # Extract clean version (without 'v' prefix) for release notes
        CLEAN_VERSION="${{ github.ref_name }}"
        CLEAN_VERSION="${CLEAN_VERSION#v}"
        echo "clean=$CLEAN_VERSION" >> $GITHUB_OUTPUT
        echo "ğŸ·ï¸ Clean version for release notes: $CLEAN_VERSION"

    - name: Organize release files
      run: |
        echo "ğŸ”§ Organizing release files by platform with deduplication..."
        mkdir -p release-files
        
        # Function to copy file with unique naming if duplicate exists
        copy_unique() {
          local src="$1"
          local dst="$2"
          local filename=$(basename "$src")
          local counter=1
          local target="$dst/$filename"
          
          # If file already exists, add counter
          while [ -f "$target" ]; do
            local base="${filename%.*}"
            local ext="${filename##*.}"
            if [ "$base" = "$filename" ]; then
              # No extension
              target="$dst/${base}-${counter}"
            else
              # Has extension
              target="$dst/${base}-${counter}.${ext}"
            fi
            counter=$((counter + 1))
          done
          
          cp "$src" "$target"
          echo "ğŸ“ Copied: $src -> $target"
        }
        
        # Process each artifact directory
        for artifact_dir in artifacts/*/; do
          echo "ğŸ” Processing: $artifact_dir"
          
          # Determine platform from directory name
          if [[ "$artifact_dir" == *"windows"* ]]; then
            platform="windows"
          elif [[ "$artifact_dir" == *"mac"* ]]; then
            platform="macos"
          elif [[ "$artifact_dir" == *"linux"* ]]; then
            platform="linux"
          else
            echo "âš ï¸ Unknown platform for $artifact_dir, skipping..."
            continue
          fi
          
          # Create platform directory
          mkdir -p "release-files/$platform"
          
          # Copy files with deduplication
          find "$artifact_dir" -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.zip" -o -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" -o -name "*.tar.gz" \) | while read -r file; do
            copy_unique "$file" "release-files/$platform"
          done
        done
        
        echo "ğŸ“‹ Final release file structure:"
        find release-files/ -type f | sort

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: release-files/**/*
        draft: false
        prerelease: false
        generate_release_notes: true
        name: "WhisperDesk Enhanced ${{ github.ref_name }}"
        body: |
          ## WhisperDesk Enhanced ${{ github.ref_name }}
          
          ğŸ‰ **New Release Available!**
          
          ### ğŸ“¦ Download Options:
          
          **ğŸ–¥ï¸ Windows (64-bit only)**:
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-win-x64.exe` - Installer
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-win-x64.zip` - Portable version
          
          **ğŸ macOS**:
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-x64.dmg` - Intel Macs
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-x64.zip` - Intel Macs (Portable)
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-arm64.dmg` - Apple Silicon Macs
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-mac-arm64.zip` - Apple Silicon Macs (Portable)
          
          **ğŸ§ Linux**:
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.AppImage` - Portable (recommended)
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.deb` - Debian/Ubuntu package
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.rpm` - Red Hat/Fedora package
          - `WhisperDesk-Enhanced-${{ steps.version.outputs.clean }}-linux-x64.tar.gz` - Generic Linux archive
          
          ### âœ¨ Features:
          - ğŸµ Native whisper.cpp integration for fast, offline transcription
          - ğŸ“± Cross-platform support (Windows, macOS, Linux)
          - ğŸ”„ Real-time progress tracking
          - ğŸ’¾ Persistent state management
          - ğŸ¯ Multiple model support (Tiny, Base, Small, Medium, Large)
          - ğŸ“ Drag & drop file upload
          - ğŸ¨ Modern, responsive UI
          
          ### ğŸš€ Quick Start:
          1. **Download**: Choose the appropriate file for your platform above
          2. **Install**: 
             - Windows: Run the installer or extract the zip
             - macOS: Open the .dmg and drag to Applications, or extract the zip
             - Linux: Make AppImage executable, install package, or extract archive
          3. **Setup**: Launch WhisperDesk and go to Models tab
          4. **Download Model**: Download a transcription model (start with Tiny)
          5. **Transcribe**: Upload audio/video files and start transcribing!
          
          ### ğŸ”§ Troubleshooting:
          - **Windows**: If you get a "missing DLL" error, run the included `vc_redist.x64.exe` redistributable
          - **macOS**: Right-click â†’ Open if blocked by Gatekeeper
          - **Linux**: `chmod +x *.AppImage` to make executable
          
          ---
          Auto-generated release notes below â¬‡ï¸
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}